#!/usr/bin/env python3

# Import builtin Python modules
import operator,subprocess,sys,os.path

# Import ERT python modules
from Python.ert_core  import ert_core

def list_2_string(text_list):
  return reduce(operator.add,[t+" " for t in text_list])

# Execute a command without generating a new shell
def execute_noshell(command,echo=True):
  if echo:
    print ("   ",list_2_string(command))
    sys.stdout.flush()

  if subprocess.call(command,shell=False) != 0:
    sys.stderr.write("  Failure...\n")
    return 1
  return 0

# Execute a command within a new shell
def execute_shell(command,echo=True):
  if echo:
    if isinstance(command,list):
      print ("   ",command[0])
    else:
      print ("   ",command)
    sys.stdout.flush()

  if subprocess.call(command,shell=True) != 0:
    sys.stderr.write("  Failure...\n")
    return 1
  return 0

# Execute a command without generating a new shell
# and return any output from "stdout"
def stdout_noshell(command,echo=True):
  if echo:
    print ("   ",list_2_string(command))
    sys.stdout.flush()

  p = subprocess.Popen(command,shell=False,stdout=subprocess.PIPE)
  output = p.communicate()[0]
  status = p.returncode
  if status != 0:
    sys.stderr.write("  Failure...\n")
    return (1,"Failure")
  return (0,output)

# Execute a command within a new shell
# and return any output from "stdout"
def stdout_shell(command,echo=True):
  if echo:
    if isinstance(command,list):
      print ("   ",command[0])
    else:
      print ("   ",command)
    sys.stdout.flush()

  p = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE)
  output = p.communicate()[0]
  status = p.returncode
  if status != 0:
    sys.stderr.write("  Failure...\n")
    return (1,"Failure")
  return (0,output)

def parse_int_list(input):
  retlist = []

  elems = input.replace(" ","").replace("\t","").split(",")
  for elem in elems:
    minmax = elem.split("-")
    if len(minmax) == 1:
      retlist.append(int(minmax[0]))
    else:
      for i in xrange(int(minmax[0]),int(minmax[1])+1):
        retlist.append(i)

  return sorted(list(set(retlist)))

# Make a new directory if it doesn't already exist
def make_dir_if_needed(dir,name,echo=True):
  if not os.path.exists(dir):
    command = ["mkdir",dir]
    if execute_noshell(command,echo) != 0:
      sys.stderr.write("Unable to make %s directory, %s\n" % (name,dir))
  else:
    return False

  return True

# Get the path to the directory where this was run
exe_path = os.path.dirname(sys.argv[0])
if exe_path == "":
  exe_path = "."

# Create the ERT object
ert = ert_core()

# Initialize the execution path
ert.exe_path = exe_path
print (exe_path)

# Parse the command line
if ert.flags() != 0:
  sys.stderr.write("\n--- Parsing command line arguments failed --- \n\n")
  sys.exit(1)
sys.stdout.flush()

# Configure the ERT using the configuration file given on the command line
if ert.configure() != 0:
  sys.stderr.write("\n--- Configuring ERT failed ---\n\n")
  sys.exit(1)
sys.stdout.flush()

# Get the list of flops/element to try (specified by the user)
flops_list = parse_int_list(ert.dict["CONFIG"]["ERT_FLOPS"][0])
print ("flop-elements")

# Go through the flops/element list and process each case
for flop in flops_list:
  # A bit of output if any verbosity has been requested
  if ert.options.verbose > 0:
    print ("FLOP count %d..." % flop)
    sys.stdout.flush()

  # Set the ERT object flops/element
  print ("Setting ERT object ",flop)
  print (" ")
  print (" ")
  ert.flop = flop

  # Create a directory for these experiments (and give it to the ERT object)
  ert.flop_dir = "%s/FLOPS.%03d" % (ert.results_dir,flop)
  make_dir_if_needed(ert.flop_dir,"run",ert.options.verbose > 1)
  print ("Creating directory ",ert.flop_dir)
  print (" ")
  print (" ")

  # Build the current code with the current flops/element
  if ert.build() != 0:
    sys.stderr.write("\n--- Building ERT failed ---\n\n")
    sys.exit(1)
  sys.stdout.flush()

  # Run the built code over a variety of MPI, OpenMP, and/or CUDA
  # configurations specified by the user
  if ert.run() != 0:
    sys.stderr.write("\n--- Running ERT failed ---\n\n")
    sys.exit(1)
  sys.stdout.flush()

  # Process all the results for the current flops/element
  if ert.process() != 0:
    sys.stderr.write("\n--- Processing ERT results failed ---\n\n")
    sys.exit(1)
  sys.stdout.flush()

  # Make graphs of all the results for the current flops/element
  if ert.graphs() != 0:
    sys.stderr.write("\n--- Making ERT individual graphs failed ---\n\n")
    sys.exit(1)
  sys.stdout.flush()

  if ert.options.verbose > 0:
    print

# When all the experiments have been processed, generate the roofline graph
# and JSON output
if ert.roofline() != 0:
  sys.stderr.write("\n--- Making ERT roofline failed ---\n\n")
  sys.exit(1)

# All done
sys.stdout.flush()
sys.exit(0)
